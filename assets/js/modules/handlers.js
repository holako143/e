import * as state from './state.js';import * as ui from './ui.js';import * as crypto from './crypto.js';import { elements } from './dom.js';import { HEADER_MARKER, SEPARATOR } from './config.js';export async function handleEncodeText() {    const text = elements.inputText.value.trim();    if (!text) return ui.showToast('يرجى إدخال نص للتشفير', 'error');    try {        ui.showToast('جاري التشفير...', 'info', 1000);        const useCompression = elements.useCompression.checked;        const useEncryption = elements.useEncrypt.checked;        const password = elements.password.value;        let payloadBytes = useCompression            ? crypto.AdvancedCompression.compress(text)            : crypto.getEncoder().encode(text);        let encResult = null;        if (useEncryption && password) {            const iterations = getEncryptionIterations();            encResult = await crypto.AdvancedEncryption.encrypt(payloadBytes, password, iterations);            payloadBytes = encResult.encrypted;        }        const header = createHeader(text, payloadBytes, useCompression, useEncryption && password, encResult);        const combinedData = assemblePayload(header, payloadBytes);        const result = crypto.encodeBytesToEmoji(state.currentActiveEmoji, combinedData);        elements.output.value = result;        ui.updateStats(header.origSize, header.compSize);        ui.showResultsSection();        if (state.appSettings.autoCopyEncodedEmoji) {            await ui.copyToClipboard(result, elements.copyBtn);        }        ui.showToast('تم تشفير النص بنجاح', 'success');        addHistoryEntry(text, result);    } catch (err) {        console.error('Encoding error:', err);        ui.showToast(`خطأ في التشفير: ${err.message}`, 'error');    }}export async function handleDecodeText() {    const src = elements.inputText.value.trim();    if (!src) return ui.showToast('يرجى إدخال نص مشفر', 'error');        ui.showToast('جاري فك التشفير...', 'info');    try {        const result = await decodeMessage(src);        if (result && result.text !== null) {            elements.output.value = result.text;            ui.updateStats(result.stats.originalSize, result.stats.compressedSize);            ui.showResultsSection();            if (state.appSettings.autoCopyDecodedText) {                await ui.copyToClipboard(result.text, elements.copyBtn);            }            ui.showToast('تم فك تشفير النص بنجاح', 'success');        }    } catch (err) {         if (err.message !== "Password required") {            ui.showToast(`خطأ في فك التشفير: ${err.message}`, 'error');        }    }}async function decodeMessage(src) {    const combinedData = crypto.decodeEmojiToBytes(src);    if (combinedData.length === 0) throw new Error('لا توجد بيانات صالحة.');    const { header, payloadBytes } = disassemblePayload(combinedData);    if (!header || !payloadBytes) throw new Error('البيانات الوصفية تالفة.');    let decryptedBytes = payloadBytes;    if (header.enc) {        const password = elements.password.value;        if (!password) {            ui.showToast('النص مشفر، يرجى إدخال كلمة السر', 'error');            throw new Error("Password required");        }        decryptedBytes = await crypto.AdvancedEncryption.decrypt(            payloadBytes, crypto.base64ToBytes(header.salt), crypto.base64ToBytes(header.iv), password, header.iter        );    }    const finalText = header.comp        ? crypto.AdvancedCompression.decompress(decryptedBytes)        : crypto.getDecoder().decode(decryptedBytes);    return {        text: finalText,        stats: { originalSize: header.origSize, compressedSize: header.compSize }    };}function getEncryptionIterations() {    if (elements.useCustomIterations.checked) {        const custom = parseInt(elements.customIterations.value, 10);        if (custom >= 10000) return custom;    }    return { low: 50000, medium: 100000, high: 200000 }[state.appSettings.encryptionStrength] || 100000;}function createHeader(text, payload, comp, enc, encResult) {    return {        v: 2, comp, enc,        ts: Date.now(),        crc: crypto.AdvancedCRC.calculate(text),        origSize: crypto.getEncoder().encode(text).length,        compSize: payload.length,        salt: encResult ? crypto.bytesToBase64(encResult.salt) : '',        iv: encResult ? crypto.bytesToBase64(encResult.iv) : '',        iter: encResult ? encResult.iterations : 0,    };}function assemblePayload(header, payloadBytes) {    const headerBytes = crypto.getEncoder().encode(JSON.stringify(header));    const markerBytes = crypto.getEncoder().encode(HEADER_MARKER);    const separatorBytes = crypto.getEncoder().encode(SEPARATOR);    const combined = new Uint8Array(markerBytes.length + headerBytes.length + separatorBytes.length + payloadBytes.length);    let offset = 0;    combined.set(markerBytes, offset);    offset += markerBytes.length;    combined.set(headerBytes, offset);    offset += headerBytes.length;    combined.set(separatorBytes, offset);    offset += separatorBytes.length;    combined.set(payloadBytes, offset);    return combined;}function disassemblePayload(combinedData) {    const markerBytes = crypto.getEncoder().encode(HEADER_MARKER);    const separatorBytes = crypto.getEncoder().encode(SEPARATOR);    const headerStart = findSubarray(combinedData, markerBytes) + markerBytes.length;    const separatorStart = findSubarray(combinedData, separatorBytes, headerStart);    if (headerStart === markerBytes.length -1 || separatorStart === -1) return {};    const headerBytes = combinedData.slice(headerStart, separatorStart);    const payloadBytes = combinedData.slice(separatorStart + separatorBytes.length);        try {        const header = JSON.parse(crypto.getDecoder().decode(headerBytes));        return { header, payloadBytes };    } catch {        return {};    }}function findSubarray(arr, sub, start = 0) {    for (let i = start; i < arr.length - sub.length + 1; i++) {        let found = true;        for (let j = 0; j < sub.length; j++) {            if (arr[i + j] !== sub[j]) {                found = false;                break;            }        }        if (found) return i;    }    return -1;}function addHistoryEntry(text, result) {    if (!state.appSettings.saveHistory) return;    state.historyItems.unshift({        text: text.substring(0, 100),        result,        timestamp: new Date().toISOString(),        operation: 'encode'    });    if (state.historyItems.length > 50) {        state.historyItems = state.historyItems.slice(0, 50);    }    state.saveHistory();    ui.renderHistory();}
