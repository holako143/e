import {    VARIATION_SELECTOR_START,    VARIATION_SELECTOR_END,    VARIATION_SELECTOR_SUPPLEMENT_START,    VARIATION_SELECTOR_SUPPLEMENT_END} from './config.js';const encoder = new TextEncoder();const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });export function getEncoder() { return encoder; }export function getDecoder() { return decoder; }export function bytesToBase64(bytes) {    const binString = String.fromCodePoint(...bytes);    return btoa(binString);}export function base64ToBytes(base64) {    const binString = atob(base64);    return Uint8Array.from(binString, m => m.codePointAt(0));}function toVariationSelector(byte) {    if (byte >= 0 && byte < 16) {        return String.fromCodePoint(VARIATION_SELECTOR_START + byte);    } else if (byte >= 16 && byte < 256) {        return String.fromCodePoint(VARIATION_SELECTOR_SUPPLEMENT_START + byte - 16);    }    return null;}function fromVariationSelector(codePoint) {    if (codePoint >= VARIATION_SELECTOR_START && codePoint <= VARIATION_SELECTOR_END) {        return codePoint - VARIATION_SELECTOR_START;    } else if (codePoint >= VARIATION_SELECTOR_SUPPLEMENT_START && codePoint <= VARIATION_SELECTOR_SUPPLEMENT_END) {        return codePoint - VARIATION_SELECTOR_SUPPLEMENT_START + 16;    }    return null;}export function encodeBytesToEmoji(emoji, bytes) {    let encoded = emoji;    for (const byte of bytes) {        encoded += toVariationSelector(byte);    }    return encoded;}export function decodeEmojiToBytes(text) {    let decoded = [];    const chars = Array.from(text);    let startIndex = 0;    for (let i = 0; i < chars.length; i++) {        const byte = fromVariationSelector(chars[i].codePointAt(0));        if (byte === null) {            startIndex = i + 1;            break;        }    }    for (let i = startIndex; i < chars.length; i++) {        const char = chars[i];        const byte = fromVariationSelector(char.codePointAt(0));        if (byte !== null) {            decoded.push(byte);        } else {            break;        }    }    return new Uint8Array(decoded);}export class AdvancedCompression {    static compress(text) {        if (!text || text.length === 0) return new Uint8Array([]);        try {            const textBytes = encoder.encode(text);                        return this.simpleRunLengthCompress(textBytes);        } catch (error) {            console.error('Compression error:', error);            return encoder.encode(text);         }    }    static decompress(data) {        if (!data || data.length === 0) return '';        try {            const decompressed = this.simpleRunLengthDecompress(data);            return decoder.decode(decompressed);        } catch (error) {            console.error('Decompression error:', error);            try {                return decoder.decode(data);             } catch (e) {                console.error('Fallback decode error:', e);                return '';            }        }    }            static simpleRunLengthCompress(data) {        const result = [];        let i = 0;        while (i < data.length) {            let count = 1;            while (i + count < data.length && data[i + count] === data[i] && count < 255) {                count++;            }            if (count > 2) {                 result.push(255, count, data[i]);            } else {                for (let j = 0; j < count; j++) {                    if (data[i] === 255) {                         result.push(255, 1, 255);                    } else {                        result.push(data[i]);                    }                }            }            i += count;        }        return new Uint8Array(result);    }    static simpleRunLengthDecompress(data) {        const result = [];        let i = 0;        while (i < data.length) {            if (data[i] === 255 && i + 1 < data.length) {                const count = data[i + 1];                const value = data[i + 2];                for (let j = 0; j < count; j++) {                    result.push(value);                }                i += 3;            } else {                result.push(data[i]);                i++;            }        }        return new Uint8Array(result);    }}export class AdvancedEncryption {    static async generateKey(password, salt, iterations) {        const keyMaterial = await crypto.subtle.importKey(            'raw',            encoder.encode(password),            'PBKDF2',            false,            ['deriveKey']        );        return crypto.subtle.deriveKey(            { name: 'PBKDF2', salt, iterations, hash: 'SHA-256' },            keyMaterial,            { name: 'AES-GCM', length: 256 },            false,            ['encrypt', 'decrypt']        );    }    static async encrypt(data, password, iterations) {        const salt = crypto.getRandomValues(new Uint8Array(32));        const iv = crypto.getRandomValues(new Uint8Array(16));        const key = await this.generateKey(password, salt, iterations);        const additionalData = encoder.encode('EmojiCipherPro-v2.1');        const encryptedData = await crypto.subtle.encrypt(            { name: 'AES-GCM', iv, additionalData },            key,            data        );        return {            encrypted: new Uint8Array(encryptedData),            salt: salt,            iv: iv,            iterations: iterations        };    }    static async decrypt(encryptedData, salt, iv, password, iterations) {        const key = await this.generateKey(password, salt, iterations);        const additionalData = encoder.encode('EmojiCipherPro-v2.1');        const decryptedData = await crypto.subtle.decrypt(            { name: 'AES-GCM', iv, additionalData },            key,            encryptedData        );        return new Uint8Array(decryptedData);    }}export class AdvancedCRC {    static crc32Table = (() => {        const table = new Uint32Array(256);        for (let i = 0; i < 256; i++) {            let c = i;            for (let j = 0; j < 8; j++) {                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);            }            table[i] = c;        }        return table;    })();    static calculate(str) {        const bytes = encoder.encode(str);        let crc = 0 ^ (-1);        for (let i = 0; i < bytes.length; i++) {            crc = (crc >>> 8) ^ this.crc32Table[(crc ^ bytes[i]) & 0xFF];        }        return (crc ^ (-1)) >>> 0;    }}
